/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cubeb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cubeb_stream {
    _unused: [u8; 0],
}
pub const CUBEB_SAMPLE_S16LE: cubeb_sample_format = 0;
pub const CUBEB_SAMPLE_S16BE: cubeb_sample_format = 1;
pub const CUBEB_SAMPLE_FLOAT32LE: cubeb_sample_format = 2;
pub const CUBEB_SAMPLE_FLOAT32BE: cubeb_sample_format = 3;
pub const CUBEB_SAMPLE_S16NE: cubeb_sample_format = 0;
pub const CUBEB_SAMPLE_FLOAT32NE: cubeb_sample_format = 2;
/// Sample format enumeration.
pub type cubeb_sample_format = ::std::os::raw::c_uint;
/// An opaque handle used to refer a particular input or output device
/// across calls.
pub type cubeb_devid = *const ::std::os::raw::c_void;
pub const CUBEB_LOG_DISABLED: cubeb_log_level = 0;
pub const CUBEB_LOG_NORMAL: cubeb_log_level = 1;
pub const CUBEB_LOG_VERBOSE: cubeb_log_level = 2;
/// Level (verbosity) of logging for a particular cubeb context.
pub type cubeb_log_level = ::std::os::raw::c_uint;
pub const CUBEB_LAYOUT_UNDEFINED: cubeb_channel_layout = 0;
pub const CUBEB_LAYOUT_DUAL_MONO: cubeb_channel_layout = 1;
pub const CUBEB_LAYOUT_DUAL_MONO_LFE: cubeb_channel_layout = 2;
pub const CUBEB_LAYOUT_MONO: cubeb_channel_layout = 3;
pub const CUBEB_LAYOUT_MONO_LFE: cubeb_channel_layout = 4;
pub const CUBEB_LAYOUT_STEREO: cubeb_channel_layout = 5;
pub const CUBEB_LAYOUT_STEREO_LFE: cubeb_channel_layout = 6;
pub const CUBEB_LAYOUT_3F: cubeb_channel_layout = 7;
pub const CUBEB_LAYOUT_3F_LFE: cubeb_channel_layout = 8;
pub const CUBEB_LAYOUT_2F1: cubeb_channel_layout = 9;
pub const CUBEB_LAYOUT_2F1_LFE: cubeb_channel_layout = 10;
pub const CUBEB_LAYOUT_3F1: cubeb_channel_layout = 11;
pub const CUBEB_LAYOUT_3F1_LFE: cubeb_channel_layout = 12;
pub const CUBEB_LAYOUT_2F2: cubeb_channel_layout = 13;
pub const CUBEB_LAYOUT_2F2_LFE: cubeb_channel_layout = 14;
pub const CUBEB_LAYOUT_3F2: cubeb_channel_layout = 15;
pub const CUBEB_LAYOUT_3F2_LFE: cubeb_channel_layout = 16;
pub const CUBEB_LAYOUT_3F3R_LFE: cubeb_channel_layout = 17;
pub const CUBEB_LAYOUT_3F4_LFE: cubeb_channel_layout = 18;
pub const CUBEB_LAYOUT_MAX: cubeb_channel_layout = 19;
/// SMPTE channel layout (also known as wave order)
/// DUAL-MONO      L   R
/// DUAL-MONO-LFE  L   R   LFE
/// MONO           M
/// MONO-LFE       M   LFE
/// STEREO         L   R
/// STEREO-LFE     L   R   LFE
/// 3F             L   R   C
/// 3F-LFE         L   R   C    LFE
/// 2F1            L   R   S
/// 2F1-LFE        L   R   LFE  S
/// 3F1            L   R   C    S
/// 3F1-LFE        L   R   C    LFE S
/// 2F2            L   R   LS   RS
/// 2F2-LFE        L   R   LFE  LS   RS
/// 3F2            L   R   C    LS   RS
/// 3F2-LFE        L   R   C    LFE  LS   RS
/// 3F3R-LFE       L   R   C    LFE  RC   LS   RS
/// 3F4-LFE        L   R   C    LFE  RLS  RRS  LS   RS
///
/// The abbreviation of channel name is defined in following table:
/// Abbr  Channel name
/// ---------------------------
/// M     Mono
/// L     Left
/// R     Right
/// C     Center
/// LS    Left Surround
/// RS    Right Surround
/// RLS   Rear Left Surround
/// RC    Rear Center
/// RRS   Rear Right Surround
/// LFE   Low Frequency Effects
pub type cubeb_channel_layout = ::std::os::raw::c_uint;
/// Stream format initialization parameters.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cubeb_stream_params {
    /// < Requested sample format.  One of
    /// #cubeb_sample_format.
    pub format: cubeb_sample_format,
    /// < Requested sample rate.  Valid range is [1000, 192000].
    pub rate: u32,
    /// < Requested channel count.  Valid range is [1, 8].
    pub channels: u32,
    /// < Requested channel layout. This must be consistent with the provided channels.
    pub layout: cubeb_channel_layout,
}
#[test]
fn bindgen_test_layout_cubeb_stream_params() {
    assert_eq!(::std::mem::size_of::<cubeb_stream_params>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( cubeb_stream_params ) ));
    assert_eq! (::std::mem::align_of::<cubeb_stream_params>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( cubeb_stream_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_stream_params ) ) . format as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_stream_params ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_stream_params ) ) . rate as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_stream_params ) ,
                "::" , stringify ! ( rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_stream_params ) ) . channels as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_stream_params ) ,
                "::" , stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_stream_params ) ) . layout as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_stream_params ) ,
                "::" , stringify ! ( layout ) ));
}
impl Clone for cubeb_stream_params {
    fn clone(&self) -> Self { *self }
}
/// Audio device description
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cubeb_device {
    /// < The name of the output device
    pub output_name: *mut ::std::os::raw::c_char,
    /// < The name of the input device
    pub input_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_cubeb_device() {
    assert_eq!(::std::mem::size_of::<cubeb_device>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cubeb_device ) ));
    assert_eq! (::std::mem::align_of::<cubeb_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cubeb_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device ) ) . output_name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device ) , "::" ,
                stringify ! ( output_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device ) ) . input_name as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device ) , "::" ,
                stringify ! ( input_name ) ));
}
impl Clone for cubeb_device {
    fn clone(&self) -> Self { *self }
}
pub const CUBEB_STATE_STARTED: cubeb_state = 0;
pub const CUBEB_STATE_STOPPED: cubeb_state = 1;
pub const CUBEB_STATE_DRAINED: cubeb_state = 2;
pub const CUBEB_STATE_ERROR: cubeb_state = 3;
/// Stream states signaled via state_callback.
pub type cubeb_state = ::std::os::raw::c_uint;
pub const CUBEB_OK: _bindgen_ty_1 = 0;
pub const CUBEB_ERROR: _bindgen_ty_1 = -1;
pub const CUBEB_ERROR_INVALID_FORMAT: _bindgen_ty_1 = -2;
pub const CUBEB_ERROR_INVALID_PARAMETER: _bindgen_ty_1 = -3;
pub const CUBEB_ERROR_NOT_SUPPORTED: _bindgen_ty_1 = -4;
pub const CUBEB_ERROR_DEVICE_UNAVAILABLE: _bindgen_ty_1 = -5;
/// Result code enumeration.
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const CUBEB_DEVICE_TYPE_UNKNOWN: cubeb_device_type = 0;
pub const CUBEB_DEVICE_TYPE_INPUT: cubeb_device_type = 1;
pub const CUBEB_DEVICE_TYPE_OUTPUT: cubeb_device_type = 2;
/// Whether a particular device is an input device (e.g. a microphone), or an
/// output device (e.g. headphones).
pub type cubeb_device_type = ::std::os::raw::c_uint;
pub const CUBEB_DEVICE_STATE_DISABLED: cubeb_device_state = 0;
pub const CUBEB_DEVICE_STATE_UNPLUGGED: cubeb_device_state = 1;
pub const CUBEB_DEVICE_STATE_ENABLED: cubeb_device_state = 2;
/// The state of a device.
pub type cubeb_device_state = ::std::os::raw::c_uint;
pub const CUBEB_DEVICE_FMT_S16LE: cubeb_device_fmt = 16;
pub const CUBEB_DEVICE_FMT_S16BE: cubeb_device_fmt = 32;
pub const CUBEB_DEVICE_FMT_F32LE: cubeb_device_fmt = 4096;
pub const CUBEB_DEVICE_FMT_F32BE: cubeb_device_fmt = 8192;
/// Architecture specific sample type.
pub type cubeb_device_fmt = ::std::os::raw::c_uint;
pub const CUBEB_DEVICE_PREF_NONE: cubeb_device_pref = 0;
pub const CUBEB_DEVICE_PREF_MULTIMEDIA: cubeb_device_pref = 1;
pub const CUBEB_DEVICE_PREF_VOICE: cubeb_device_pref = 2;
pub const CUBEB_DEVICE_PREF_NOTIFICATION: cubeb_device_pref = 4;
pub const CUBEB_DEVICE_PREF_ALL: cubeb_device_pref = 15;
/// Channel type for a `cubeb_stream`. Depending on the backend and platform
/// used, this can control inter-stream interruption, ducking, and volume
/// control.
pub type cubeb_device_pref = ::std::os::raw::c_uint;
/// This structure holds the characteristics
/// of an input or output audio device. It is obtained using
/// `cubeb_enumerate_devices`, which returns these structures via
/// `cubeb_device_collection` and must be destroyed via
/// `cubeb_device_collection_destroy`.
#[repr(C)]
#[derive(Debug)]
pub struct cubeb_device_info {
    /// < Device identifier handle.
    pub devid: cubeb_devid,
    /// < Device identifier which might be presented in a UI.
    pub device_id: *const ::std::os::raw::c_char,
    /// < Friendly device name which might be presented in a UI.
    pub friendly_name: *const ::std::os::raw::c_char,
    /// < Two devices have the same group identifier if they belong to the same physical device; for example a headset and microphone.
    pub group_id: *const ::std::os::raw::c_char,
    /// < Optional vendor name, may be NULL.
    pub vendor_name: *const ::std::os::raw::c_char,
    /// < Type of device (Input/Output).
    pub type_: cubeb_device_type,
    /// < State of device disabled/enabled/unplugged.
    pub state: cubeb_device_state,
    /// < Preferred device.
    pub preferred: cubeb_device_pref,
    /// < Sample format supported.
    pub format: cubeb_device_fmt,
    /// < The default sample format for this device.
    pub default_format: cubeb_device_fmt,
    /// < Channels.
    pub max_channels: u32,
    /// < Default/Preferred sample rate.
    pub default_rate: u32,
    /// < Maximum sample rate supported.
    pub max_rate: u32,
    /// < Minimum sample rate supported.
    pub min_rate: u32,
    /// < Lowest possible latency in frames.
    pub latency_lo: u32,
    /// < Higest possible latency in frames.
    pub latency_hi: u32,
}
#[test]
fn bindgen_test_layout_cubeb_device_info() {
    assert_eq!(::std::mem::size_of::<cubeb_device_info>() , 88usize , concat !
               ( "Size of: " , stringify ! ( cubeb_device_info ) ));
    assert_eq! (::std::mem::align_of::<cubeb_device_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cubeb_device_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . devid as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( devid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . device_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . friendly_name as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( friendly_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . group_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( group_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . vendor_name as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( vendor_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . type_ as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . state as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . preferred as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( preferred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . format as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . default_format as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( default_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . max_channels as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( max_channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . default_rate as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( default_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . max_rate as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( max_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . min_rate as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( min_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . latency_lo as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( latency_lo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_info ) ) . latency_hi as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_info ) ,
                "::" , stringify ! ( latency_hi ) ));
}
/// Device collection.
/// Returned by `cubeb_enumerate_devices` and destroyed by
/// `cubeb_device_collection_destroy`.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cubeb_device_collection {
    /// < Array of pointers to device info.
    pub device: *mut cubeb_device_info,
    /// < Device count in collection.
    pub count: usize,
}
#[test]
fn bindgen_test_layout_cubeb_device_collection() {
    assert_eq!(::std::mem::size_of::<cubeb_device_collection>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( cubeb_device_collection ) ));
    assert_eq! (::std::mem::align_of::<cubeb_device_collection>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cubeb_device_collection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_collection ) ) . device as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_collection
                ) , "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cubeb_device_collection ) ) . count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cubeb_device_collection
                ) , "::" , stringify ! ( count ) ));
}
impl Clone for cubeb_device_collection {
    fn clone(&self) -> Self { *self }
}
/// User supplied data callback.
/// - Calling other cubeb functions from this callback is unsafe.
/// - The code in the callback should be non-blocking.
/// - Returning less than the number of frames this callback asks for or
/// provides puts the stream in drain mode. This callback will not be called
/// again, and the state callback will be called with CUBEB_STATE_DRAINED when
/// all the frames have been output.
/// @param stream The stream for which this callback fired.
/// @param user_ptr The pointer passed to cubeb_stream_init.
/// @param input_buffer A pointer containing the input data, or nullptr
/// if this is an output-only stream.
/// @param output_buffer A pointer to a buffer to be filled with audio samples,
/// or nullptr if this is an input-only stream.
/// @param nframes The number of frames of the two buffer.
/// @retval Number of frames written to the output buffer. If this number is
/// less than nframes, then the stream will start to drain.
/// @retval CUBEB_ERROR on error, in which case the data callback will stop
/// and the stream will enter a shutdown state.
pub type cubeb_data_callback =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut cubeb_stream,
                                               user_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               input_buffer:
                                                   *const ::std::os::raw::c_void,
                                               output_buffer:
                                                   *mut ::std::os::raw::c_void,
                                               nframes:
                                                   ::std::os::raw::c_long)
                              -> ::std::os::raw::c_long>;
/// User supplied state callback.
/// @param stream The stream for this this callback fired.
/// @param user_ptr The pointer passed to cubeb_stream_init.
/// @param state The new state of the stream.
pub type cubeb_state_callback =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut cubeb_stream,
                                               user_ptr:
                                                   *mut ::std::os::raw::c_void,
                                               state: cubeb_state)>;
/// User supplied callback called when the underlying device changed.
/// @param user The pointer passed to cubeb_stream_init.
pub type cubeb_device_changed_callback =
    ::std::option::Option<unsafe extern "C" fn(user_ptr:
                                                   *mut ::std::os::raw::c_void)>;
/// User supplied callback called when the underlying device collection changed.
/// @param context A pointer to the cubeb context.
/// @param user_ptr The pointer passed to cubeb_register_device_collection_changed.
pub type cubeb_device_collection_changed_callback =
    ::std::option::Option<unsafe extern "C" fn(context: *mut cubeb,
                                               user_ptr:
                                                   *mut ::std::os::raw::c_void)>;
/// User supplied callback called when a message needs logging.
pub type cubeb_log_callback =
    ::std::option::Option<unsafe extern "C" fn(fmt:
                                                   *const ::std::os::raw::c_char, ...)>;
